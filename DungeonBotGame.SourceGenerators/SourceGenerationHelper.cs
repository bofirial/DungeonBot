using System.Text;
using DungeonBotGame.Foundation;

namespace DungeonBotGame.SourceGenerators;

public static class SourceGenerationHelper
{
    public static string GenerateDungeonBotPartialClass(
        DungeonBotPartialClassToGenerate dungeonBotPartialClassToGenerate,
        IEnumerable<AbilityType> targettedAbilities,
        IEnumerable<AbilityType> nonTargettedAbilities)
    {
        var sb = new StringBuilder();
        sb.Append(@"// <auto-generated/>

#nullable enable
using System.ComponentModel;
using System.Collections.Immutable;
using DungeonBotGame.Combat;
using DungeonBotGame.Foundation;
");
        if (!string.IsNullOrWhiteSpace(dungeonBotPartialClassToGenerate.Namespace))
        {
            sb.Append(@$"
namespace {dungeonBotPartialClassToGenerate.Namespace};
");
        }

        sb.Append(@"
public partial class ").Append(dungeonBotPartialClassToGenerate.Name).Append(@"
{
    private short CurrentHealth { get; }
    private short MaximumHealth { get; }
    private short Level { get; }
    private short Power { get; }
    private short Armor { get; }
    private short Speed { get; }
    private IImmutableList<CombatEffect> CombatEffects { get; }
    private IImmutableDictionary<AbilityType, AbilityContext> Abilities { get; }

    public ").Append(dungeonBotPartialClassToGenerate.Name).Append(@"(
        short currentHealth,
        short maximumHealth,
        short level,
        short power,
        short armor,
        short speed,
        IImmutableList<CombatEffect> combatEffects,
        IImmutableDictionary<AbilityType, AbilityContext> abilities)
    {
        CurrentHealth = currentHealth;
        MaximumHealth = maximumHealth;
        Level = level;
        Power = power;
        Armor = armor;
        Speed = speed;
        CombatEffects = combatEffects;
        Abilities = abilities;

        OnInit();
    }

    partial void OnInit();

    [EditorBrowsable(EditorBrowsableState.Never)]
    public bool AbilityIsAvailable(AbilityType abilityType) => Abilities.ContainsKey(abilityType) && Abilities[abilityType].IsAvailable;
    [EditorBrowsable(EditorBrowsableState.Never)]
    public IAbilityAction UseAbility(AbilityType abilityType) => new AbilityAction(abilityType);
    [EditorBrowsable(EditorBrowsableState.Never)]
    public ITargettedAbilityAction UseTargettedAbility(ITarget target, AbilityType abilityType) => new TargettedAbilityAction(target, abilityType);

    public ITargettedAction Attack(ITarget attackTarget) => new AttackAction(attackTarget);");

        foreach (var targettedAbility in targettedAbilities)
        {
            sb.Append(@"

    public bool ").Append(targettedAbility).Append(@"IsAvailable() => AbilityIsAvailable(AbilityType.").Append(targettedAbility).Append(@");
    public ITargettedAbilityAction Use").Append(targettedAbility).Append(@"(ITarget target) => UseTargettedAbility(target, AbilityType.").Append(targettedAbility).Append(@");");
        }

        foreach (var nonTargettedAbility in nonTargettedAbilities)
        {
            sb.Append(@"

    public bool ").Append(nonTargettedAbility).Append(@"IsAvailable() => AbilityIsAvailable(AbilityType.").Append(nonTargettedAbility).Append(@");
    public IAbilityAction Use").Append(nonTargettedAbility).Append(@"(ITarget target) => UseAbility(AbilityType.").Append(nonTargettedAbility).Append(@");");
        }

        sb.Append(@"
}");

        return sb.ToString();
    }
}

